#Written by Gary Zeri, part of UCI, NS2 Furche Group

#load py2Bash class
from atomParser import atomParser
py2Bash = atomParser()

import os
import bisect

#Class to extract specified energies from Turbomole simulation
#Requires out file from jobex script in order to function properly
class energyExtractor():

#////////////////////////////////////////////////////////////////////

	#constants used in this class
	
	#dictionary containing strings grep uses to find energy lines in out file
	energyPhrases = {
		
		"ridft":"|  total energy",
		#to get 2nd gradient norm, of the noadiabatic coupling matrix
		"egrad":"gradient norm", 
		"rdgrad":"gradient norm"

}	

#////////////////////////////////////////////////////////////////////

	#function to extract energies associated with a specific MD step
	#ts is string of time step numbers to parse, "1,2,3,4,7-10"
	#outfile is name of outfile generated by jobex script
	#which types of energies should be extracted, sould be strings of program names separated by commas
	def MDEnergy(self, ts, outFile="out.out", energyType = "ridft, egrad, rdgrad"):
		
		#parse ts data passed in by user
		ts2 = ts.split(",")	
		
		#iterate through all ts passed in by 
		for ts in ts2:
			#check if multiple timesteps are to be parsed from jobex outfile
			if("-" in ts):
				tsData = [int(data) for data in ts.split("-")]
			
			#else if single ts only in this string
			else:
				tsData = [int(ts), int(ts)]	

		#get linenumbers of all md steps in out file
		MDLines = self.getMDLines(outFile)

		#get lineNumbers of all energies requested by the user
		energyLines = getEnergyLines(outFile, energyType)		
				
		print(MDLines)
	
		#loop to iterate through all timesteps passed in
		for tsNumberRaw in range( tsData[1] - tsData[0] + 1  ):
			
			#calculate actual ts number
			tsNumber = tsNumberRaw + tsData[0]

			print("TS to parse " + str(tsNumber + tsData[0]) + "\n")

			#get line number of specified md step in outfile
			line = MDLines[ tsNumber - 1  ]	
			
			#iterate through all energies user requested
			#sort list to be sure it is in numerical order
			#use bisect to find energy starting lines that is just before this MD step, and corresponds to its energy
			correspondingEnergy = [ energy[bisect.bisect(energy.sort(), line) - 1] for energy in energyLines]			

			print(correspondingEnergy)

			#parse out specifed energy text "blocks" from jobex out file and place each in its own separate file
			for CE in correspondingEnergy:
				os.pop						


#////////////////////////////////////////////////////////////////////
	
	#function to return order in which energies passed in by user are computed for each "set"	
	def getEnergyOrder(energyLines):
		
		#create list of tuples containing last lines from energy as well as index of energy location in energyLines
		#then sort this list based on first tuple to see which line comes first for the last "step" in out.out
		energyOrder = [ [energyLines[energy][len(energyLines[energy])-1], energy] for energy in range(len(energyLines))].sort()
	
		#only return list of ordered indexes of energy calculations
		return [ tup[1] for tup in energyOrder]

#////////////////////////////////////////////////////////////////////

	#funtion to get line numbers of all MD steps
	def getMDLines(self, outFile):
		return py2Bash.grep("M o l e c u l a r", outFile)[0]
		
#////////////////////////////////////////////////////////////////////

	#funtion to get line numbers of all MD steps
	def getEnergyLines(self, outFile, energyType, MDStep=-1):
		
		#parse user input
		userInput = energyType.lower().split(",")
			
		return [ py2Bash.grep(" ".join(ui), outFile)[0]  for ui in userInput  ]
		
#////////////////////////////////////////////////////////////////////
