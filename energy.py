#Written by Gary Zeri, part of UCI, NS2 Furche Group

#load py2Bash class
from atomParser import atomParser
py2Bash = atomParser()

import os
import bisect

#Class to extract specified energies from Turbomole simulation
#Requires out file from jobex script in order to function properly
class energyExtractor():

#////////////////////////////////////////////////////////////////////

	#energy types user can pass in to extract values
	#ridft = ridft convergence energy
	#nacm = norm of the nonadiabatic coupling matrix, 2nd gradient norm value
	#ex1 energy of first excited state, total energy 

	#constants used in this class
	
	#dictionary containing strings grep uses to find energy lines in out file
	energyPhrases = {
		
		"ridft":"'|  total energy'",
		#to get 2nd gradient norm, of the nonadiabatic coupling matrix
		"nacm":"'gradient norm'", 
		"ex1": "'Total energy:'"
}
	
	#contains data that is used to turn string data into a float
	#len of array/2 gives number of times loop should run
	#first value is string to split original line at, and second value is which position of resulting array should script access
	energyParseCommands = {

	"ridft": [ ["=", 1], ["|", 0] ],
	"nacm": [ ["\n", 1], [":", 1] ],
	"ex1": [ ["\n", 1], [":", 1] ]
	
}	

	#given user inputed energy key word, returns location step name that contains that energy
	energyBlock = {

		"ridft":"ridft",
		"nacm":"egrad",
		"ex1":"egrad"

}

#////////////////////////////////////////////////////////////////////

	#function to extract energies associated with a specific MD step
	#ts is string of time step numbers to parse, "1,2,3,4,7-10"
	#outfile is name of outfile generated by jobex script
	#which types of energies should be extracted, sould be strings of program names separated by commas
	def getMDEnergy(self, ts, outFile="out.out", energyType = "ridft,nacm,ex1"):
		
		
		
		#user input
		userInput = [ui for ui in energyType.split(",")]		
	
		#parse ts data passed in by user
		ts2 = ts.split(",")	
		
		#init empty ts data holder
		tsData = []
		#parse ts data
		
		#iterate through all ts passed in by 
		for ts in ts2:
			#check if multiple timesteps are to be parsed from jobex outfile
			if("-" in ts):
				tsData += range(int(ts.split("-")[0]), int(ts.split("-")[1]) + 1)
			
			#else if single ts only in this string
			else:
				tsData.append(int(float(ts)))

		#get linenumbers of all md steps in out file
		MDLines = self.getMDLines(outFile)

		#get lineNumbers of all energies requested by the user
		energyLines = self.getEnergyLines(outFile, energyType)		
				
		#get order in which energy is calculated for each md step
		energyOrder = self.getEnergyOrder(energyLines)
		
		print("####")
		print(tsData)
	
		#init MD Energy dictionary to store and organize all energies
		MDEnergy = {
			
			#list of all timesteps calculated
			"ts":tsData,
			#list of all energies calculated
			"energy":userInput	
		}
		for energy in userInput:
			MDEnergy[energy] = []

		#loop to iterate through all timesteps passed in
		for tsNumber in tsData:
			
			print("TS to parse " + str(tsNumber) + "\n")

			#get line number of specified md step in outfile
			line = MDLines[ tsNumber - 1  ]	
			
			#iterate through all energies user requested
			#sort list to be sure it is in numerical order
			#use bisect to find energy starting lines that is just before this MD step, and corresponds to its energy
			correspondingEnergy = [ energy[bisect.bisect(energy, line) - 1] for energy in energyLines]			

			#parse out specifed energy text "blocks" from jobex out file and place each in its own separate file
			for energy in range(len(energyOrder)):
				
				#if on last energy, instead of copying lines from specifed energy step to last energy step, go to md step
				if(energy == len(energyOrder)-1):
					endingLine = line
				else:
					endingLine = correspondingEnergy[energyOrder[energy+1]]

				#get starting line of energy step
				startingLine = correspondingEnergy[energyOrder[energy]]


				
				for phrase in self.getUBE(userInput, userInput[energyOrder[energy]]):
				#for each type of energy user wants that is contained in this block, 
				#pull out energy section and pipe section data to grep with energy keyword to parse out energy
					rawEnergy = os.popen( "sed -n '" + str(startingLine) + "," + str(endingLine) + "p' 'out.out' | grep -I " + phrase).read()

					os.popen( "sed -n '" + str(startingLine) + "," + str(endingLine) + "p' 'out.out' > test")
					#get user inputted energy keyword that relates to this raw energy data
					energyType = self.energyPhrases.keys()[self.energyPhrases.values().index(phrase)]
					
					#append energy into appropriate position on MD Energy dictionary
					MDEnergy[ energyType ].append( self.parseRawData(rawEnergy, energyType) )
						


		return MDEnergy

#////////////////////////////////////////////////////////////////////
	
	#function to return order in which energies passed in by user are computed for each "set"	
	def getEnergyOrder(self, energyLines):
		print("GEO")
		
		#create list of tuples containing last lines from energy as well as index of energy location in energyLines
		#then sort this list based on first tuple to see which line comes first for the last "step" in out.out
		energyOrder = [ [energyLines[energy][len(energyLines[energy])-1], energy] for energy in range(len(energyLines))]
		energyOrder.sort()
		#only return list of ordered indexes of energy calculations
		return [ tup[1] for tup in energyOrder]

#////////////////////////////////////////////////////////////////////

	#funtion to get line numbers of all MD steps
	def getMDLines(self, outFile):
		return py2Bash.grep("M o l e c u l a r", outFile)[0]
		
#////////////////////////////////////////////////////////////////////

	#funtion to get line numbers of all MD steps
	def getEnergyLines(self, outFile, energyType, MDStep=-1):
		
		#parse user input, and get blocks where requested energy is calculated
		userInput = list(set([ self.energyBlock[energy] for energy in energyType.lower().split(",") ] ))
			
	#	userInput = [ self.energyBlock[energy] for energy in energyType.lower().split(",") ]
		#use grep to get energy lines and then sort line numbers numerically
		energyLines = [ py2Bash.grep(" ".join(ui), outFile)[0]  for ui in userInput  ]
		energyLines.sort()

		return energyLines
		
#////////////////////////////////////////////////////////////////////

	#function to parse raw energy data line from file and get float of energy from line string
	def parseRawData(self, rawData, energyType):

		print(rawData)

		print(energyType)
		#init empty data var
		data = ""

		#loop over all commands needed to parse this energytype
		for command in self.energyParseCommands[energyType]:
			
			#execute commands to split and parse rawdata
			data = rawData.split(command[0])[command[1]]
			rawData = data						
	
		print("%%%%%%%%%%%%%%%%%%%%\n")
		print(rawData)
	
		return float(rawData)

#////////////////////////////////////////////////////////////////////

	#function to get all user wanted energies from an energy block
	def getUBE(self, userInput, specificInput):

		#init empty energy phrase list
		energyPhrase = []
		
		#get all values and keys of energy block, aka all block names and which inputted energy coresponds to that name
		values = self.energyBlock.values()
		keys = self.energyBlock.keys()
		#get name of actual block in question from specified user inputted energy
		block = self.energyBlock[specificInput]
	
		#loop over all possible energy blocks
		for value in range(len(values)):

			#if the the type of block is equal to the specified user block, 
			#then get which energy input results in that block and append the 
			#energyphrase related to that energy input to the energyphrase list
			if(values[value] == block):
				energyPhrase.append(self.energyPhrases[ keys[value] ])

		return energyPhrase
