#Written by Gary Zeri, part of UCI, NS2 Furche Group

#load py2Bash class
from atomParser import atomParser
py2Bash = atomParser()

import os
import bisect

#Class to extract specified energies from Turbomole simulation
#Requires out file from jobex script in order to function properly
class energyExtractor():

#////////////////////////////////////////////////////////////////////

	#constants used in this class
	
	#dictionary containing strings grep uses to find energy lines in out file
	energyPhrases = {
		
		"ridft":"'|  total energy'",
		#to get 2nd gradient norm, of the noadiabatic coupling matrix
		"egrad":"'gradient norm'", 
		"rdgrad":"'gradient norm'"

}	

#////////////////////////////////////////////////////////////////////

	#function to extract energies associated with a specific MD step
	#ts is string of time step numbers to parse, "1,2,3,4,7-10"
	#outfile is name of outfile generated by jobex script
	#which types of energies should be extracted, sould be strings of program names separated by commas
	def getMDEnergy(self, ts, outFile="out.out", energyType = "ridft,egrad"):
		
		
		
		#user input
		userInput = [ui for ui in energyType.split(",")]		
	
		#parse ts data passed in by user
		ts2 = ts.split(",")	
		
		#init empty ts data holder
		tsData = []
		print(ts2)	
		#parse ts data
		
		#iterate through all ts passed in by 
		for ts in ts2:
			#check if multiple timesteps are to be parsed from jobex outfile
			if("-" in ts):
				tsData += range(int(ts.split("-")[0]), int(ts.split("-")[1]) + 1)
			
			#else if single ts only in this string
			else:
				tsData.append(int(ts))

		#get linenumbers of all md steps in out file
		MDLines = self.getMDLines(outFile)

		#get lineNumbers of all energies requested by the user
		energyLines = self.getEnergyLines(outFile, energyType)		
				
		#get order in which energy is calculated for each md step
		energyOrder = self.getEnergyOrder(energyLines)
		
		print("####")
		print(tsData)
	
		#init MD Energy dictionary to store and organize all energies
		MDEnergy = {
			
			#list of all timesteps calculated
			"ts":tsData,
			#list of all energies calculated
			"energy":userInput	
		}
		for energy in userInput:
			MDEnergy[energy] = []

		#loop to iterate through all timesteps passed in
		for tsNumber in tsData:
			
			print("TS to parse " + str(tsNumber) + "\n")

			#get line number of specified md step in outfile
			line = MDLines[ tsNumber - 1  ]	
			
			#iterate through all energies user requested
			#sort list to be sure it is in numerical order
			#use bisect to find energy starting lines that is just before this MD step, and corresponds to its energy
			correspondingEnergy = [ energy[bisect.bisect(energy, line) - 1] for energy in energyLines]			

			#parse out specifed energy text "blocks" from jobex out file and place each in its own separate file
			for energy in range(len(energyOrder)):
				
				#if on last energy, instead of copying lines from specifed energy step to last energy step, go to md step
				if(energy == len(energyOrder)-1):
					endingLine = line
				else:
					endingLine = correspondingEnergy[energyOrder[energy+1]]

				#get starting line of energy step
				startingLine = correspondingEnergy[energyOrder[energy]]

				#pull out energy section and pipe section data to grep with energy keyword to parse out energy 
				rawEnergy = os.popen( "sed -n '" + str(startingLine) + "," + str(endingLine) + "p' 'out.out' | grep " + self.energyPhrases[userInput[energyOrder[energy]]]).read()
				
				print(rawEnergy)
				
				#append energy into appropriate position on MD Energy dictionary
				MDEnergy[userInput[energyOrder[energy]]].append(rawEnergy)


		return MDEnergy

#////////////////////////////////////////////////////////////////////
	
	#function to return order in which energies passed in by user are computed for each "set"	
	def getEnergyOrder(self, energyLines):
		print("GEO")
		
		#create list of tuples containing last lines from energy as well as index of energy location in energyLines
		#then sort this list based on first tuple to see which line comes first for the last "step" in out.out
		energyOrder = [ [energyLines[energy][len(energyLines[energy])-1], energy] for energy in range(len(energyLines))]
		energyOrder.sort()
		print(energyOrder)
		#only return list of ordered indexes of energy calculations
		return [ tup[1] for tup in energyOrder]

#////////////////////////////////////////////////////////////////////

	#funtion to get line numbers of all MD steps
	def getMDLines(self, outFile):
		return py2Bash.grep("M o l e c u l a r", outFile)[0]
		
#////////////////////////////////////////////////////////////////////

	#funtion to get line numbers of all MD steps
	def getEnergyLines(self, outFile, energyType, MDStep=-1):
		
		#parse user input
		userInput = energyType.lower().split(",")
			
		#use grep to get energy lines and then sort line numbers numerically
		energyLines = [ py2Bash.grep(" ".join(ui), outFile)[0]  for ui in userInput  ]

		return energyLines
		
#////////////////////////////////////////////////////////////////////

	#function to parse raw energy data line from file and get float of energy from line string
	def parseRawData(self, rawData, energyType):

		return rawData
